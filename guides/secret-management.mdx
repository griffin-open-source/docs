---
title: "Secret Management"
description: "Resolve sensitive values securely at runtime"
---

## Overview

Griffin includes secret management so your test plans can reference sensitive values without committing them to source control. Secrets are resolved at runtime by the runner, keeping credentials out of your test files and generated plans.

## Supported Providers

The runner supports multiple secret backends so you can match your environment:

- **Environment variables**: Ideal for local development and simple deployments.
- **AWS Secrets Manager**: Centralized secrets in AWS with IAM-based access control.
- **HashiCorp Vault**: Enterprise-grade secret management with flexible auth.

## How It Works

1. **Reference secrets by name** in your test configuration (for example, in headers or request bodies).
2. **Deploy the test** without any secret values embedded.
3. **Runner resolves secrets at execution time** using the configured provider.

This keeps your repository clean while still enabling authenticated or credentialed API checks.

## Local Development

For local runs, use environment variables so secrets stay on your machine:

- Export secrets in your shell before running `griffin run-local`.
- Keep secrets out of test files and avoid committing them to the repo.

## Production Usage

For production deployments, configure the runner to use a managed secret provider:

- Store credentials in AWS Secrets Manager or HashiCorp Vault.
- Grant the runner access using least-privilege permissions.
- Rotate secrets in the provider without redeploying tests.

## Best Practices

- Never commit secrets to source control or test plans.
- Use different secrets per environment (dev/staging/prod).
- Limit scope: create dedicated credentials just for tests.
- Audit access and rotate secrets regularly.
