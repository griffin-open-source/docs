---
title: "Plan Executor"
description: "How Griffin executes test plans"
---

## Overview

The Griffin Plan Executor is the runtime engine that takes JSON test plans and executes them. It handles graph-based execution, HTTP requests, waits, and assertions.

## How It Works

The executor follows a simple but powerful model:

1. **Load Plan**: Reads the JSON test plan
2. **Build Graph**: Constructs an execution graph from nodes and edges
3. **Traverse Graph**: Follows edges from START to END
4. **Execute Nodes**: Runs endpoints, waits, and assertions
5. **Collect Results**: Tracks execution results and timing

## Test Plan Format

The executor expects JSON test plans with this structure:

```json
{
  "name": "my-check",
  "endpoint_host": "http://localhost:3000",
  "nodes": {
    "START": { "type": "start" },
    "health": {
      "type": "endpoint",
      "method": "GET",
      "path": "/health",
      "response_format": "JSON"
    },
    "wait-1s": {
      "type": "wait",
      "duration": 1000
    },
    "END": { "type": "end" }
  },
  "edges": [
    { "from": "START", "to": "health" },
    { "from": "health", "to": "wait-1s" },
    { "from": "wait-1s", "to": "END" }
  ]
}
```

## Node Types

### START Node

The entry point of every test plan.

```json
{
  "START": { "type": "start" }
}
```

- Must be present in every plan
- Must have at least one outgoing edge
- Execution always begins here

### END Node

The exit point of every test plan.

```json
{
  "END": { "type": "end" }
}
```

- Must be present in every plan
- Must have at least one incoming edge
- Execution completes when this node is reached

### Endpoint Nodes

Represent HTTP API calls.

```json
{
  "get-users": {
    "type": "endpoint",
    "method": "GET",
    "path": "/users",
    "response_format": "JSON",
    "headers": {
      "Authorization": "Bearer token123"
    }
  }
}
```

**Properties**:
- `method`: HTTP method (GET, POST, PUT, DELETE, PATCH)
- `path`: API endpoint path (relative to `endpoint_host`)
- `response_format`: Expected response format (JSON, XML, TEXT, HTML)
- `headers`: Optional HTTP headers
- `body`: Optional request body (for POST, PUT, PATCH)
- `timeout`: Optional timeout in milliseconds

### Wait Nodes

Add delays between test steps.

```json
{
  "wait-1s": {
    "type": "wait",
    "duration": 1000
  }
}
```

**Properties**:
- `duration`: Wait time in milliseconds

### Assertion Nodes

Validate responses (implementation coming soon).

```json
{
  "check-status": {
    "type": "assertion",
    "endpoint": "get-users",
    "condition": "status_code",
    "expected": 200
  }
}
```

## Graph Execution

The executor uses a graph-based execution model:

### Execution Flow

1. **Start at START**: Begin execution at the START node
2. **Follow Edges**: Move to connected nodes via edges
3. **Execute Node**: Run the node's operation (endpoint, wait, assertion)
4. **Continue**: Follow outgoing edges to next nodes
5. **Complete**: Finish when END node is reached

### Sequential Execution

```json
{
  "edges": [
    { "from": "START", "to": "step1" },
    { "from": "step1", "to": "step2" },
    { "from": "step2", "to": "step3" },
    { "from": "step3", "to": "END" }
  ]
}
```

Executes: START → step1 → step2 → step3 → END

### Parallel Branches

```json
{
  "edges": [
    { "from": "START", "to": "common" },
    { "from": "common", "to": "branch1" },
    { "from": "common", "to": "branch2" },
    { "from": "branch1", "to": "END" },
    { "from": "branch2", "to": "END" }
  ]
}
```

Executes both branches: common → branch1 → END and common → branch2 → END

## Execution Modes

### Local Execution

Runs tests in the same process as the CLI or runner.

**Use Cases**:
- Development and testing
- Quick validation
- CI/CD pipelines

**Characteristics**:
- Fast startup
- Direct process execution
- Easy debugging

### Remote Execution

Runs tests in separate environments (Lambda, containers, etc.).

**Use Cases**:
- Production monitoring
- Distributed execution
- Isolated test environments

**Characteristics**:
- Scalable
- Isolated
- Can run from multiple locations

## HTTP Request Execution

When executing an endpoint node:

1. **Build URL**: Combine `endpoint_host` with `path`
2. **Prepare Request**: Add headers, body, method
3. **Send Request**: Make HTTP request with timeout
4. **Parse Response**: Parse based on `response_format`
5. **Store Result**: Save response for use in assertions or variables
6. **Continue**: Move to next node via edges

### Request Building

```typescript
// Example: GET request
const url = `${endpoint_host}${path}`;
const response = await fetch(url, {
  method: "GET",
  headers: { ...headers }
});
```

### Response Parsing

```typescript
// JSON response
if (response_format === "JSON") {
  return await response.json();
}

// Text response
if (response_format === "TEXT") {
  return await response.text();
}
```

## Variable Extraction

The executor supports extracting values from responses:

```json
{
  "create-user": {
    "type": "endpoint",
    "method": "POST",
    "path": "/users",
    "extract": {
      "userId": "$.id"
    }
  }
}
```

Extracted variables can be used in subsequent requests:

```json
{
  "get-user": {
    "type": "endpoint",
    "method": "GET",
    "path": "/users/{userId}"
  }
}
```

## Error Handling

### Timeout Handling

If a request exceeds the timeout:

1. Cancel the request
2. Mark the node as failed
3. Record timeout error
4. Continue execution (if configured) or stop

### HTTP Error Handling

For non-2xx status codes:

1. Parse error response
2. Mark node as failed (unless `expected_status` matches)
3. Record error details
4. Continue or stop based on configuration

### Graph Traversal Errors

If a node cannot be reached:

1. Check for missing edges
2. Validate graph structure
3. Report graph errors
4. Stop execution

## Execution Results

The executor collects detailed results:

```json
{
  "plan_name": "my-check",
  "status": "passed",
  "duration": 1234,
  "nodes": {
    "health": {
      "status": "passed",
      "duration": 45,
      "response": {
        "status_code": 200,
        "body": { "status": "ok" }
      }
    }
  },
  "errors": []
}
```

**Result Properties**:
- `status`: Overall test status (passed, failed, error)
- `duration`: Total execution time in milliseconds
- `nodes`: Results for each executed node
- `errors`: Any errors encountered during execution

## Performance Considerations

### Concurrent Execution

The executor can run multiple tests concurrently:

- Each test plan executes independently
- No shared state between tests
- Results are collected separately

### Resource Management

- HTTP connections are pooled and reused
- Timeouts prevent hanging requests
- Memory usage scales with test complexity

## Integration

### With CLI

The CLI uses the executor to run tests locally:

```typescript
const executor = new PlanExecutor();
const result = await executor.execute(plan);
console.log(result);
```

### With Runner

The runner service uses the executor for scheduled tests:

```typescript
// Runner schedules test
scheduler.schedule("my-check", () => {
  const executor = new PlanExecutor();
  return executor.execute(plan);
});
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Test System Guide" icon="code" href="/guides/test-system">
    Learn how test plans are created.
  </Card>
  <Card title="Architecture" icon="sitemap" href="/guides/architecture">
    Understand the full system architecture.
  </Card>
</CardGroup>
