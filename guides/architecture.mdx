---
title: "Architecture"
description: "Understand how Griffin components work together"
---

## Overview

Griffin uses a hub-and-agent architecture for distributed API testing. The system enables multi-location test execution with comprehensive observability through event streaming. Tests are written in TypeScript, stored as JSON monitors, and executed by distributed agents coordinated by a central hub.

## Component Architecture

<Frame>
  <img src="/images/architecture-diagram.png" alt="Griffin architecture diagram showing the flow from test files to execution" />
</Frame>

## Core Components

### 1. griffin-ts

TypeScript DSL library for defining API test monitors with two builder patterns.

**Purpose**: Define API tests using type-safe, chainable builders

**Key Features**:
- Sequential builder for simple linear workflows
- Graph builder for complex test flows with branching
- Support for endpoints, waits, assertions, and secrets
- Outputs JSON monitors for execution
- Full TypeScript support with type inference

**Location**: `packages/griffin-ts/`

**Usage (Sequential)**:
```typescript
import { createTestBuilder, GET, JSON, Assert, Frequency } from "griffin-ts";

const monitor = createTestBuilder({
  name: "health-check",
  endpoint_host: "http://localhost:3000"
})
  .endpoint("health", { method: GET, response_format: JSON, path: "/health" })
  .assert((state) => [Assert(state["health"].status).equals(200)])
  .build({ frequency: Frequency.every(1).minute() });

export default monitor;
```

**Usage (Graph)**:
```typescript
import { createGraphBuilder, START, END, Frequency } from "griffin-ts";

const monitor = createGraphBuilder({...})
  .addEndpoint("health", {...})
  .addEdge(START, "health")
  .addEdge("health", END)
  .build({ frequency: Frequency.every(15).minutes() });
```

### 2. griffin-cli

Command-line tool for local development and hub management.

**Purpose**: Developer interface with environment management and OIDC authentication

**Key Features**:
- Auto-discovers test files in `__griffin__/` directories
- Local test execution with environment switching
- Hub authentication via OIDC device flow or API keys
- Monitor deployment and run history management
- State management via `.griffin/state.json`

**Location**: `packages/griffin-cli/`

**Commands**:
- `griffin init` - Initialize Griffin in project
- `griffin env list|add|remove` - Manage environments
- `griffin local run <environment>` - Run tests locally
- `griffin hub login` - Authenticate with hub (OIDC)
- `griffin hub connect --url <url> --token <token>` - Connect with API key
- `griffin hub apply <environment>` - Deploy monitors to hub
- `griffin hub runs [--limit N]` - View run history
- `griffin hub monitor <environment>` - List monitors
- `griffin validate` - Validate test files

### 3. griffin-executor

Core execution engine with graph-based flow control and event emission.

**Purpose**: Runtime execution of JSON monitors with full observability

**Key Features**:
- Graph-based execution using topological sorting (ts-edge library)
- Emits execution events for every HTTP request, response, and assertion
- Multi-provider secrets management (env, AWS Secrets Manager, Vault)
- Kinesis event adapter for cloud integration
- Support for HTTP endpoints, waits, and assertions

**Location**: `packages/griffin-executor/`

**Execution Flow**:
1. Loads JSON monitor
2. Resolves secrets from configured providers
3. Builds execution graph with topological sorting
4. Emits `MONITOR_START` event
5. Executes nodes following graph edges
6. Emits events for each HTTP request/response and assertion
7. Emits `MONITOR_END` event with results

**Event Types**:
- `MONITOR_START` - Monitor execution begins
- `HTTP_REQUEST` - Before HTTP call
- `HTTP_RESPONSE` - After HTTP call
- `ASSERTION_RESULT` - Assertion evaluation
- `MONITOR_END` - Monitor execution completes

### 4. griffin-hub

Control plane service managing monitors, scheduling, and agent coordination.

**Purpose**: Centralized orchestration for distributed test execution

**Key Features**:
- Two deployment modes: standalone (built-in executor) or distributed (with agents)
- Monitor management REST API with auto-generated TypeScript SDK
- Frequency-based scheduler with configurable tick intervals
- Agent registry with heartbeat monitoring
- PostgreSQL or SQS-backed job queues
- Metrics aggregation and notification support

**Location**: `packages/griffin-hub/`

**Deployment Modes**:

**Standalone Mode** (`npm run start:standalone`):
- Single process combining hub + executor
- All jobs routed to `local` location
- Simpler deployment for single-instance setups

**Distributed Mode** (`npm start`):
- Hub only, coordinates remote agents
- Agents poll job queues (PostgreSQL or SQS)
- Multi-location support with geographic distribution
- Horizontal scaling with multiple agents

**REST API Endpoints**:
- `POST /monitor` - Create or update monitor
- `GET /monitor/:name` - Get monitor details
- `DELETE /monitor/:name` - Delete monitor
- `GET /runs` - List execution runs
- `GET /agents` - List registered agents
- `GET /config` - Get hub configuration

## Data Flow

### Local Development Flow

1. **Initialize**: Developer runs `griffin init` and `griffin env add dev`
2. **Write Test**: Create `.ts` file in `__griffin__/` directory using `createTestBuilder`
3. **Discover**: CLI scans for test files matching `**/__griffin__/*.{ts,js}`
4. **Compile**: TypeScript DSL generates JSON monitor
5. **Execute**: griffin-executor runs monitor locally
6. **Report**: Results displayed in terminal

### Hub Deployment Flow (Standalone Mode)

1. **Deploy**: Run `griffin hub apply <environment>` to upload monitors
2. **Schedule**: Hub scheduler enqueues jobs based on frequency
3. **Execute**: Built-in executor processes jobs from queue
4. **Emit Events**: Executor emits events during execution
5. **Store**: Results stored in PostgreSQL
6. **View**: Use `griffin hub runs` to see execution history

### Hub-Agent Flow (Distributed Mode)

1. **Deploy Monitors**: CLI uploads monitors to hub via REST API
2. **Agent Registration**: Agents register with hub and send heartbeats
3. **Schedule**: Hub scheduler enqueues jobs with location targeting
4. **Agent Polling**: Agents poll job queue for their location
5. **Execute**: Agent executor runs monitor and emits events
6. **Event Streaming**: Events flow to Kinesis → Firehose → S3
7. **Analytics**: Query S3 data via Athena or ClickHouse Cloud
8. **Alerting**: Failed tests trigger SNS notifications

## Monitor Structure

Monitors are JSON documents generated from TypeScript DSL:

```json
{
  "version": "2.0.0",
  "name": "health-check",
  "endpoint_host": "http://localhost:3000",
  "frequency": {
    "type": "minute",
    "value": 1
  },
  "nodes": [
    {
      "id": "START",
      "type": "start"
    },
    {
      "id": "health",
      "type": "endpoint",
      "method": "GET",
      "path": "/health",
      "response_format": "JSON"
    },
    {
      "id": "END",
      "type": "end"
    }
  ],
  "edges": [
    { "from": "START", "to": "health" },
    { "from": "health", "to": "END" }
  ]
}
```

**Monitor Versioning**: Griffin uses a migrate-on-read strategy for backward compatibility. Monitors are stored in their original version and migrated when loaded by the executor.

## Graph-Based Execution

Griffin uses a graph-based execution model where:
- **Nodes** represent test steps (endpoints, waits, assertions)
- **Edges** define the flow between steps
- Execution starts at `START` and follows edges until `END` is reached
- This allows for complex test flows with branching and conditional logic

## Integration Points

### griffin-ts → JSON Monitors

The DSL outputs version-tagged JSON monitors that are:
- Language-agnostic (can be executed anywhere)
- Stored in hub's PostgreSQL database
- Validated on upload to ensure correctness

### CLI → Hub (REST API)

CLI authenticates and communicates with hub via:
- OIDC device authorization flow for user authentication
- API keys for programmatic access
- Auto-generated TypeScript SDK (griffin-hub-sdk)

**API Operations**:
- Upload/update monitors
- List monitors and runs
- Trigger manual executions
- Query agent health

### Hub → Job Queue

Hub scheduler enqueues jobs using:
- **PostgreSQL Backend**: Default, uses `executor_jobs` table
- **SQS Backend**: AWS-native for distributed deployments

Queue partitioning by location enables multi-region execution.

### Agent → Hub

Agents maintain connection via:
- **Registration**: Agent announces location and capabilities
- **Heartbeat**: Periodic health checks (configurable interval)
- **Job Polling**: Agents poll location-specific queues
- **Result Reporting**: Execution results stored in PostgreSQL

### Executor → Event Streams

Executor emits events for observability:
- **Local Development**: Events logged to console
- **Cloud Deployment**: Events sent to Kinesis Data Stream
- **Downstream Consumers**:
  - Firehose → S3 (data lake in Parquet format)
  - Lambda → Polar.sh (usage metering)
  - Lambda → SNS (failure alerting)

## Hub-and-Agent Architecture

### Why Hub-and-Agent?

The hub-and-agent pattern enables:
- **Multi-Location Testing**: Deploy agents in different geographic regions
- **Horizontal Scaling**: Add more agents to handle increased load
- **Fault Tolerance**: Hub monitors agent health via heartbeats
- **Location Targeting**: Route jobs to specific regions or zones

### Agent Deployment

Agents can be deployed in:
- **AWS Lambda**: Serverless execution for cost efficiency
- **Containers**: ECS, Kubernetes for persistent agents
- **VMs**: Traditional compute instances

### Location-Based Routing

Monitors can specify execution location:
```typescript
.build({
  frequency: Frequency.every(5).minutes(),
  location: "us-east-1"
})
```

Hub routes jobs to agents registered with matching location.

## Event-Driven Observability

### Event Architecture

Griffin emits structured events during test execution:

**Event Flow**:
1. Executor emits events during monitor run
2. Events sent to Kinesis Data Stream
3. Firehose delivers to S3 (Parquet format)
4. Lambda functions process events for:
   - Usage metering (Polar.sh integration)
   - Failure alerting (SNS notifications)
5. Analytics via Athena queries or ClickHouse Cloud

**Event Schema**:
- Timestamp and execution context
- Monitor name and run ID
- Event type (HTTP_REQUEST, ASSERTION_RESULT, etc.)
- Detailed payload (request/response data, assertion results)

### Analytics & Metrics

**Current (MVP)**: Athena SQL queries over S3 data lake
**Planned (Phase 2)**: ClickHouse Cloud for real-time dashboards

Metrics API supports:
- Run count by monitor
- Success/failure rates
- Response time percentiles
- Error rate tracking

## Extension Points

Griffin is designed to be extensible:

- **Custom Secret Providers**: Add new secret backends beyond env/AWS/Vault
- **Custom Job Queues**: Implement Redis or RabbitMQ queue backends
- **Custom Event Adapters**: Send events to different streaming services
- **Custom Assertions**: Add new assertion types to DSL
- **Custom Analytics**: Build dashboards on S3 event data

## Next Steps

<CardGroup cols={2}>
  <Card title="Test System Guide" icon="code" href="/guides/test-system">
    Learn how to write tests using the TypeScript DSL.
  </Card>
  <Card title="CLI Reference" icon="terminal" href="/guides/cli">
    Explore all CLI commands and options.
  </Card>
  <Card title="Plan Executor" icon="play" href="/guides/executor">
    Understand how test plans are executed.
  </Card>
  <Card title="Runner Service" icon="server" href="/guides/runner">
    Set up production test execution.
  </Card>
</CardGroup>
